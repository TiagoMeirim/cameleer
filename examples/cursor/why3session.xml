<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE why3session PUBLIC "-//Why3//proof session v5//EN"
"http://why3.lri.fr/why3session.dtd">
<why3session shape_version="6">
<prover id="0" name="Alt-Ergo" version="2.3.2" timelimit="1" steplimit="0" memlimit="1000"/>
<prover id="1" name="CVC4" version="1.7" timelimit="1" steplimit="0" memlimit="1000"/>
<file format="ocaml" proved="true">
<path name=".."/><path name="cursor.ml"/>
<theory name="Refinement__CursorList" proved="true">
 <goal name="Cursor.permitted_empty" proved="true">
 <proof prover="1"><result status="valid" time="0.14" steps="42954"/></proof>
 </goal>
 <goal name="Cursor.next&#39;refn&#39;vc" expl="VC for next&#39;refn" proved="true">
 <proof prover="1"><result status="valid" time="0.09" steps="39459"/></proof>
 </goal>
 <goal name="Cursor.has_next&#39;refn&#39;vc" expl="VC for has_next&#39;refn" proved="true">
 <proof prover="1"><result status="valid" time="0.06" steps="37246"/></proof>
 </goal>
</theory>
<theory name="Cursor" proved="true">
 <goal name="CursorList.t&#39;vc" expl="VC for t" proved="true">
 <transf name="split_vc" proved="true" >
  <goal name="t&#39;vc.0" expl="VC for t" proved="true">
  <transf name="assert" proved="true" arg1="(seq_of_list (Nil: list a) = seq_of_list (Nil: list a) ++ seq_of_list (Nil: list a))">
   <goal name="t&#39;vc.0.0" expl="asserted formula" proved="true">
   <proof prover="1"><result status="valid" time="0.14" steps="44191"/></proof>
   </goal>
   <goal name="t&#39;vc.0.1" expl="VC for t" proved="true">
   <proof prover="1"><result status="valid" time="0.09" steps="38024"/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="CursorList.seq_of_list_append" proved="true">
 <transf name="split_vc" proved="true" >
  <goal name="seq_of_list_append.0" proved="true">
  <transf name="induction_arg_ty_lex" proved="true" arg1="l1">
   <goal name="seq_of_list_append.0.0" proved="true">
   <proof prover="0"><result status="valid" time="0.16" steps="608"/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="CursorList.seq_of_list_length" proved="true">
 <transf name="split_vc" proved="true" >
  <goal name="seq_of_list_length.0" proved="true">
  <transf name="induction_arg_ty_lex" proved="true" arg1="l">
   <goal name="seq_of_list_length.0.0" proved="true">
   <transf name="split_vc" proved="true" >
    <goal name="seq_of_list_length.0.0.0" proved="true">
    <proof prover="1"><result status="valid" time="0.12" steps="42350"/></proof>
    </goal>
    <goal name="seq_of_list_length.0.0.1" proved="true">
    <proof prover="0"><result status="valid" time="0.03" steps="63"/></proof>
    </goal>
   </transf>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="CursorList.seq_of_list_mem" proved="true">
 <transf name="split_vc" proved="true" >
  <goal name="seq_of_list_mem.0" proved="true">
  <transf name="induction_arg_ty_lex" proved="true" arg1="l">
   <goal name="seq_of_list_mem.0.0" proved="true">
   <transf name="split_vc" proved="true" >
    <goal name="seq_of_list_mem.0.0.0" proved="true">
    <proof prover="1"><result status="valid" time="0.12" steps="40993"/></proof>
    </goal>
    <goal name="seq_of_list_mem.0.0.1" proved="true">
    <transf name="case" proved="true" arg1="(x1 = x2)">
     <goal name="seq_of_list_mem.0.0.1.0" expl="true case" proved="true">
     <proof prover="0"><result status="valid" time="0.07" steps="399"/></proof>
     </goal>
     <goal name="seq_of_list_mem.0.0.1.1" expl="false case" proved="true">
     <proof prover="1" timelimit="5"><result status="valid" time="1.30" steps="199504"/></proof>
     </goal>
    </transf>
    </goal>
   </transf>
   </goal>
  </transf>
  </goal>
  <goal name="seq_of_list_mem.1" proved="true">
  <transf name="induction_arg_ty_lex" proved="true" arg1="l">
   <goal name="seq_of_list_mem.1.0" proved="true">
   <transf name="split_vc" proved="true" >
    <goal name="seq_of_list_mem.1.0.0" proved="true">
    <proof prover="1"><result status="valid" time="0.15" steps="43124"/></proof>
    </goal>
    <goal name="seq_of_list_mem.1.0.1" proved="true">
    <proof prover="1"><result status="valid" time="0.82" steps="151424"/></proof>
    </goal>
   </transf>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="CursorList.next&#39;vc" expl="VC for next" proved="true">
 <transf name="split_vc" proved="true" >
  <goal name="next&#39;vc.0" expl="unreachable point" proved="true">
  <proof prover="0"><result status="valid" time="0.03" steps="73"/></proof>
  </goal>
  <goal name="next&#39;vc.1" expl="type invariant" proved="true">
  <transf name="split_vc" proved="true" >
   <goal name="next&#39;vc.1.0" expl="type invariant" proved="true">
   <proof prover="0"><result status="valid" time="0.12" steps="566"/></proof>
   </goal>
  </transf>
  </goal>
  <goal name="next&#39;vc.2" expl="postcondition" proved="true">
  <proof prover="1"><result status="valid" time="1.34" steps="206265"/></proof>
  </goal>
  <goal name="next&#39;vc.3" expl="postcondition" proved="true">
  <proof prover="1"><result status="valid" time="0.06" steps="37573"/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="CursorList.has_next&#39;vc" expl="VC for has_next" proved="true">
 <proof prover="1"><result status="valid" time="0.20" steps="58746"/></proof>
 </goal>
 <goal name="CursorList.create&#39;vc" expl="VC for create" proved="true">
 <proof prover="1"><result status="valid" time="0.18" steps="44136"/></proof>
 </goal>
 <goal name="sum_cursor&#39;vc" expl="VC for sum_cursor" proved="true">
 <transf name="split_vc" proved="true" >
  <goal name="sum_cursor&#39;vc.0" expl="loop invariant init" proved="true">
  <proof prover="1"><result status="valid" time="0.26" steps="67869"/></proof>
  </goal>
  <goal name="sum_cursor&#39;vc.1" expl="loop invariant init" proved="true">
  <proof prover="1"><result status="valid" time="0.18" steps="46780"/></proof>
  </goal>
  <goal name="sum_cursor&#39;vc.2" expl="precondition" proved="true">
  <proof prover="1"><result status="valid" time="0.07" steps="37207"/></proof>
  </goal>
  <goal name="sum_cursor&#39;vc.3" expl="precondition" proved="true">
  <proof prover="1"><result status="valid" time="0.07" steps="37299"/></proof>
  </goal>
  <goal name="sum_cursor&#39;vc.4" expl="loop variant decrease" proved="true">
  <transf name="split_vc" proved="true" >
   <goal name="sum_cursor&#39;vc.4.0" expl="loop variant decrease" proved="true">
   <proof prover="1"><result status="valid" time="0.15" steps="44715"/></proof>
   </goal>
   <goal name="sum_cursor&#39;vc.4.1" expl="loop variant decrease" proved="true">
   <proof prover="0"><result status="valid" time="0.02" steps="89"/></proof>
   </goal>
  </transf>
  </goal>
  <goal name="sum_cursor&#39;vc.5" expl="loop invariant preservation" proved="true">
  <proof prover="1"><result status="valid" time="0.08" steps="37356"/></proof>
  </goal>
  <goal name="sum_cursor&#39;vc.6" expl="loop invariant preservation" proved="true">
  <transf name="split_vc" proved="true" >
   <goal name="sum_cursor&#39;vc.6.0" expl="loop invariant preservation" proved="true">
   <transf name="assert" proved="true" arg1="(logic_sum (fun (i:int) -&gt; (visited c)[i]) 0 (length (visited c)) = logic_sum (fun (i:int) -&gt; (visited c)[i]) 0 (length (visited c1)) + x)">
    <goal name="sum_cursor&#39;vc.6.0.0" expl="asserted formula" proved="true">
    <transf name="remove" proved="true" arg1="zero2,one2,(-),(&gt;),(&lt;=),(&gt;=),abs,min,max,get2,set2,([]&#39;&#39;&#39;&#39;),([&lt;-]&#39;&#39;),int63&#39;maxInt,int63&#39;minInt,min_int63,max_int63,to_int,in_bounds,zero1,one1,(!),is_nil,length5,mem3,(==&#39;),subset,is_empty,singleton,disjoint,is_none,nth,(++&#39;&#39;),reverse,rev_append1,([]&#39;&#39;),singleton1,cons1,snoc1,(++&#39;),of_list,point_wise,mem2,iseq,occ,occ_all,seq_eq_sub,exchange1,permut1,permut_sub1,permut_all1,exchange,permut,array_eq,permut_sub,permut_all,([]&#39;&#39;&#39;),(%),get1,is_pre_order1,rev,append,(/),integer_of_int,is_pre_order,length1,([]&#39;),(==&#39;&#39;),empty2,seq_of_list1,int_of_peano,(==),cons,(++),mem,seq_of_list,permitted,complete,Assoc1,Unit_def_l,Unit_def_r,Inv_def_l,Inv_def_r,Comm1,Assoc,Mul_distr_l,Mul_distr_r,Comm,Unitary,NonTrivialRing,Refl,Trans,Antisymm,Total,ZeroLessOne,CompatOrderAdd,CompatOrderMult,Abs_le,Abs_pos,Min_r,Max_l,Min_comm,Max_comm,Min_assoc,Max_assoc,Div_mod,Div_bound,Mod_bound,Div_sign_pos,Div_sign_neg,Mod_sign_pos,Mod_sign_neg,Rounds_toward_zero,Div_1,Mod_1,Div_inf,Mod_inf,Div_mult,Mod_mult,numof&#39;def,Numof_bounds,Numof_append,Numof_left_no_add,Numof_left_add,Empty,Full,numof_increasing,numof_strictly_increasing,numof_change_any,numof_change_some,numof_change_equiv,to_int_in_bounds,extensionality1,max_int&#39;def,min_int&#39;def,is_nil&#39;spec,Length_nonnegative,Length_nil,extensionality,subset_refl,subset_trans,is_empty_empty,empty_is_empty,add_def,mem_singleton,remove_def,add_remove,remove_add,subset_remove,union_def,subset_union_1,subset_union_2,inter_def,subset_inter_1,subset_inter_2,diff_def,subset_diff,pick_def,disjoint_inter_empty,disjoint_diff_eq,disjoint_diff_s2,filter_def,subset_filter,map_def,mem_map,cardinal_nonneg,cardinal_empty,cardinal_add,cardinal_remove,cardinal_subset,subset_eq,cardinal1,cardinal_union,cardinal_inter_disjoint,cardinal_diff,cardinal_filter,cardinal_map,is_none&#39;spec,Append_assoc,Append_l_nil,Append_length,mem_append2,mem_decomp,reverse_append,reverse_cons,cons_reverse,reverse_reverse,reverse_mem,Reverse_length,rev_append_append_l,rev_append_length,rev_append_def,rev_append_append_r,non_neg_max_array_length,length_nonnegative1,(==)&#39;spec,create&#39;spec,empty&#39;def,set&#39;spec,set&#39;def,([&lt;-])&#39;def,singleton&#39;spec,cons&#39;spec,snoc&#39;spec,([..])&#39;spec,([..])&#39;def,([_..])&#39;def,([.._])&#39;def,(++)&#39;spec,to_list_empty,to_list_cons,to_list_length,to_list_nth,to_list_def_cons,length_of_list,elts_seq_of_list,is_of_list,of_list_app,of_list_app_length,of_list_snoc,convolution_to_of_list,mem_append1,mem_tail1,occ_cons,occ_snoc,occ_tail,append_num_occ,exchange_set,exchange_permut_sub1,Permut_sub_weakening,permut_refl,permut_sym,permut_trans,permut_exists,permut_all_mem,exchange_permut_all1,array&#39;invariant,permut_sub_weakening,exchange_permut_sub,exchange_permut_all,array&#39;invariant1,([&lt;-])&#39;spec,make&#39;spec,cmp_eq,non_neg_max_array_length1,logic_sum_left,logic_sum_ext,logic_sum_le,logic_sum_zero,logic_sum_nonneg,logic_sum_decomp,shift_left,zero&#39;def,one&#39;def,ext_eq,lenght_empty,append_empty_right,append_empty_left,append_assoc,snoc_empty,mem_append,mem_tail,permitted_empty,t&#39;invariant,seq_of_list_append,seq_of_list_length,seq_exists_tail,seq_mem_tail,seq_of_list_mem,H9,H8,H6,H5,H4,H2,Ensures,H,H7,H3">
     <goal name="sum_cursor&#39;vc.6.0.0.0" expl="asserted formula" proved="true">
     <proof prover="0"><result status="valid" time="0.02" steps="81"/></proof>
     </goal>
    </transf>
    </goal>
    <goal name="sum_cursor&#39;vc.6.0.1" expl="loop invariant preservation" proved="true">
    <proof prover="0" timelimit="5"><result status="valid" time="1.38" steps="740"/></proof>
    </goal>
   </transf>
   </goal>
  </transf>
  </goal>
  <goal name="sum_cursor&#39;vc.7" expl="postcondition" proved="true">
  <transf name="split_vc" proved="true" >
   <goal name="sum_cursor&#39;vc.7.0" expl="postcondition" proved="true">
   <proof prover="1"><result status="valid" time="0.87" steps="154172"/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="Mem.mem_cursor&#39;vc" expl="VC for mem_cursor" proved="true">
 <transf name="split_vc" proved="true" >
  <goal name="mem_cursor&#39;vc.0" expl="loop invariant init" proved="true">
  <proof prover="1"><result status="valid" time="0.43" steps="67926"/></proof>
  </goal>
  <goal name="mem_cursor&#39;vc.1" expl="loop invariant init" proved="true">
  <proof prover="1"><result status="valid" time="0.13" steps="42506"/></proof>
  </goal>
  <goal name="mem_cursor&#39;vc.2" expl="precondition" proved="true">
  <proof prover="1"><result status="valid" time="0.07" steps="37170"/></proof>
  </goal>
  <goal name="mem_cursor&#39;vc.3" expl="precondition" proved="true">
  <proof prover="1"><result status="valid" time="0.07" steps="37262"/></proof>
  </goal>
  <goal name="mem_cursor&#39;vc.4" expl="postcondition" proved="true">
  <transf name="split_vc" proved="true" >
   <goal name="mem_cursor&#39;vc.4.0" expl="postcondition" proved="true">
   <proof prover="0" timelimit="5"><result status="valid" time="1.93" steps="3013"/></proof>
   </goal>
  </transf>
  </goal>
  <goal name="mem_cursor&#39;vc.5" expl="loop variant decrease" proved="true">
  <proof prover="0"><result status="valid" time="0.03" steps="115"/></proof>
  </goal>
  <goal name="mem_cursor&#39;vc.6" expl="loop invariant preservation" proved="true">
  <proof prover="1"><result status="valid" time="0.08" steps="37315"/></proof>
  </goal>
  <goal name="mem_cursor&#39;vc.7" expl="loop invariant preservation" proved="true">
  <proof prover="0"><result status="valid" time="0.06" steps="258"/></proof>
  </goal>
  <goal name="mem_cursor&#39;vc.8" expl="postcondition" proved="true">
  <transf name="split_vc" proved="true" >
   <goal name="mem_cursor&#39;vc.8.0" expl="postcondition" proved="true">
   <proof prover="1"><result status="valid" time="0.08" steps="37324"/></proof>
   </goal>
   <goal name="mem_cursor&#39;vc.8.1" expl="postcondition" proved="true">
   <proof prover="1"><result status="valid" time="0.28" steps="67029"/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
</theory>
</file>
</why3session>
